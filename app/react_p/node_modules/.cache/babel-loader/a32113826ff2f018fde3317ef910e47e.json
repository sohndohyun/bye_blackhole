{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nfunction startSession(mechanisms) {\n  if (mechanisms.indexOf('SCRAM-SHA-256') === -1) {\n    throw new Error('SASL: Only mechanism SCRAM-SHA-256 is currently supported');\n  }\n\n  const clientNonce = crypto.randomBytes(18).toString('base64');\n  return {\n    mechanism: 'SCRAM-SHA-256',\n    clientNonce,\n    response: 'n,,n=*,r=' + clientNonce,\n    message: 'SASLInitialResponse'\n  };\n}\n\nfunction continueSession(session, password, serverData) {\n  if (session.message !== 'SASLInitialResponse') {\n    throw new Error('SASL: Last message was not SASLInitialResponse');\n  }\n\n  if (typeof password !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string');\n  }\n\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string');\n  }\n\n  const sv = parseServerFirstMessage(serverData);\n\n  if (!sv.nonce.startsWith(session.clientNonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce');\n  } else if (sv.nonce.length === session.clientNonce.length) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short');\n  }\n\n  var saltBytes = Buffer.from(sv.salt, 'base64');\n  var saltedPassword = Hi(password, saltBytes, sv.iteration);\n  var clientKey = hmacSha256(saltedPassword, 'Client Key');\n  var storedKey = sha256(clientKey);\n  var clientFirstMessageBare = 'n=*,r=' + session.clientNonce;\n  var serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration;\n  var clientFinalMessageWithoutProof = 'c=biws,r=' + sv.nonce;\n  var authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof;\n  var clientSignature = hmacSha256(storedKey, authMessage);\n  var clientProofBytes = xorBuffers(clientKey, clientSignature);\n  var clientProof = clientProofBytes.toString('base64');\n  var serverKey = hmacSha256(saltedPassword, 'Server Key');\n  var serverSignatureBytes = hmacSha256(serverKey, authMessage);\n  session.message = 'SASLResponse';\n  session.serverSignature = serverSignatureBytes.toString('base64');\n  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof;\n}\n\nfunction finalizeSession(session, serverData) {\n  if (session.message !== 'SASLResponse') {\n    throw new Error('SASL: Last message was not SASLResponse');\n  }\n\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string');\n  }\n\n  const {\n    serverSignature\n  } = parseServerFinalMessage(serverData);\n\n  if (serverSignature !== session.serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match');\n  }\n}\n/**\n * printable       = %x21-2B / %x2D-7E\n *                   ;; Printable ASCII except \",\".\n *                   ;; Note that any \"printable\" is also\n *                   ;; a valid \"value\".\n */\n\n\nfunction isPrintableChars(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: text must be a string');\n  }\n\n  return text.split('').map((_, i) => text.charCodeAt(i)).every(c => c >= 0x21 && c <= 0x2b || c >= 0x2d && c <= 0x7e);\n}\n/**\n * base64-char     = ALPHA / DIGIT / \"/\" / \"+\"\n *\n * base64-4        = 4base64-char\n *\n * base64-3        = 3base64-char \"=\"\n *\n * base64-2        = 2base64-char \"==\"\n *\n * base64          = *base64-4 [base64-3 / base64-2]\n */\n\n\nfunction isBase64(text) {\n  return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);\n}\n\nfunction parseAttributePairs(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: attribute pairs text must be a string');\n  }\n\n  return new Map(text.split(',').map(attrValue => {\n    if (!/^.=/.test(attrValue)) {\n      throw new Error('SASL: Invalid attribute pair entry');\n    }\n\n    const name = attrValue[0];\n    const value = attrValue.substring(2);\n    return [name, value];\n  }));\n}\n\nfunction parseServerFirstMessage(data) {\n  const attrPairs = parseAttributePairs(data);\n  const nonce = attrPairs.get('r');\n\n  if (!nonce) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing');\n  } else if (!isPrintableChars(nonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters');\n  }\n\n  const salt = attrPairs.get('s');\n\n  if (!salt) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing');\n  } else if (!isBase64(salt)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64');\n  }\n\n  const iterationText = attrPairs.get('i');\n\n  if (!iterationText) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing');\n  } else if (!/^[1-9][0-9]*$/.test(iterationText)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count');\n  }\n\n  const iteration = parseInt(iterationText, 10);\n  return {\n    nonce,\n    salt,\n    iteration\n  };\n}\n\nfunction parseServerFinalMessage(serverData) {\n  const attrPairs = parseAttributePairs(serverData);\n  const serverSignature = attrPairs.get('v');\n\n  if (!serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing');\n  } else if (!isBase64(serverSignature)) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64');\n  }\n\n  return {\n    serverSignature\n  };\n}\n\nfunction xorBuffers(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    throw new TypeError('first argument must be a Buffer');\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    throw new TypeError('second argument must be a Buffer');\n  }\n\n  if (a.length !== b.length) {\n    throw new Error('Buffer lengths must match');\n  }\n\n  if (a.length === 0) {\n    throw new Error('Buffers cannot be empty');\n  }\n\n  return Buffer.from(a.map((_, i) => a[i] ^ b[i]));\n}\n\nfunction sha256(text) {\n  return crypto.createHash('sha256').update(text).digest();\n}\n\nfunction hmacSha256(key, msg) {\n  return crypto.createHmac('sha256', key).update(msg).digest();\n}\n\nfunction Hi(password, saltBytes, iterations) {\n  var ui1 = hmacSha256(password, Buffer.concat([saltBytes, Buffer.from([0, 0, 0, 1])]));\n  var ui = ui1;\n\n  for (var i = 0; i < iterations - 1; i++) {\n    ui1 = hmacSha256(password, ui1);\n    ui = xorBuffers(ui, ui1);\n  }\n\n  return ui;\n}\n\nmodule.exports = {\n  startSession,\n  continueSession,\n  finalizeSession\n};","map":{"version":3,"sources":["/Users/jinkim/bye_blackhole/app/node_modules/pg/lib/sasl.js"],"names":["crypto","require","startSession","mechanisms","indexOf","Error","clientNonce","randomBytes","toString","mechanism","response","message","continueSession","session","password","serverData","sv","parseServerFirstMessage","nonce","startsWith","length","saltBytes","Buffer","from","salt","saltedPassword","Hi","iteration","clientKey","hmacSha256","storedKey","sha256","clientFirstMessageBare","serverFirstMessage","clientFinalMessageWithoutProof","authMessage","clientSignature","clientProofBytes","xorBuffers","clientProof","serverKey","serverSignatureBytes","serverSignature","finalizeSession","parseServerFinalMessage","isPrintableChars","text","TypeError","split","map","_","i","charCodeAt","every","c","isBase64","test","parseAttributePairs","Map","attrValue","name","value","substring","data","attrPairs","get","iterationText","parseInt","a","b","isBuffer","createHash","update","digest","key","msg","createHmac","iterations","ui1","concat","ui","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst crypto = require('crypto')\n\nfunction startSession(mechanisms) {\n  if (mechanisms.indexOf('SCRAM-SHA-256') === -1) {\n    throw new Error('SASL: Only mechanism SCRAM-SHA-256 is currently supported')\n  }\n\n  const clientNonce = crypto.randomBytes(18).toString('base64')\n\n  return {\n    mechanism: 'SCRAM-SHA-256',\n    clientNonce,\n    response: 'n,,n=*,r=' + clientNonce,\n    message: 'SASLInitialResponse',\n  }\n}\n\nfunction continueSession(session, password, serverData) {\n  if (session.message !== 'SASLInitialResponse') {\n    throw new Error('SASL: Last message was not SASLInitialResponse')\n  }\n  if (typeof password !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string')\n  }\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string')\n  }\n\n  const sv = parseServerFirstMessage(serverData)\n\n  if (!sv.nonce.startsWith(session.clientNonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce')\n  } else if (sv.nonce.length === session.clientNonce.length) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short')\n  }\n\n  var saltBytes = Buffer.from(sv.salt, 'base64')\n\n  var saltedPassword = Hi(password, saltBytes, sv.iteration)\n\n  var clientKey = hmacSha256(saltedPassword, 'Client Key')\n  var storedKey = sha256(clientKey)\n\n  var clientFirstMessageBare = 'n=*,r=' + session.clientNonce\n  var serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration\n\n  var clientFinalMessageWithoutProof = 'c=biws,r=' + sv.nonce\n\n  var authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof\n\n  var clientSignature = hmacSha256(storedKey, authMessage)\n  var clientProofBytes = xorBuffers(clientKey, clientSignature)\n  var clientProof = clientProofBytes.toString('base64')\n\n  var serverKey = hmacSha256(saltedPassword, 'Server Key')\n  var serverSignatureBytes = hmacSha256(serverKey, authMessage)\n\n  session.message = 'SASLResponse'\n  session.serverSignature = serverSignatureBytes.toString('base64')\n  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof\n}\n\nfunction finalizeSession(session, serverData) {\n  if (session.message !== 'SASLResponse') {\n    throw new Error('SASL: Last message was not SASLResponse')\n  }\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string')\n  }\n\n  const { serverSignature } = parseServerFinalMessage(serverData)\n\n  if (serverSignature !== session.serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match')\n  }\n}\n\n/**\n * printable       = %x21-2B / %x2D-7E\n *                   ;; Printable ASCII except \",\".\n *                   ;; Note that any \"printable\" is also\n *                   ;; a valid \"value\".\n */\nfunction isPrintableChars(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: text must be a string')\n  }\n  return text\n    .split('')\n    .map((_, i) => text.charCodeAt(i))\n    .every((c) => (c >= 0x21 && c <= 0x2b) || (c >= 0x2d && c <= 0x7e))\n}\n\n/**\n * base64-char     = ALPHA / DIGIT / \"/\" / \"+\"\n *\n * base64-4        = 4base64-char\n *\n * base64-3        = 3base64-char \"=\"\n *\n * base64-2        = 2base64-char \"==\"\n *\n * base64          = *base64-4 [base64-3 / base64-2]\n */\nfunction isBase64(text) {\n  return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text)\n}\n\nfunction parseAttributePairs(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: attribute pairs text must be a string')\n  }\n\n  return new Map(\n    text.split(',').map((attrValue) => {\n      if (!/^.=/.test(attrValue)) {\n        throw new Error('SASL: Invalid attribute pair entry')\n      }\n      const name = attrValue[0]\n      const value = attrValue.substring(2)\n      return [name, value]\n    })\n  )\n}\n\nfunction parseServerFirstMessage(data) {\n  const attrPairs = parseAttributePairs(data)\n\n  const nonce = attrPairs.get('r')\n  if (!nonce) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing')\n  } else if (!isPrintableChars(nonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters')\n  }\n  const salt = attrPairs.get('s')\n  if (!salt) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing')\n  } else if (!isBase64(salt)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64')\n  }\n  const iterationText = attrPairs.get('i')\n  if (!iterationText) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing')\n  } else if (!/^[1-9][0-9]*$/.test(iterationText)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count')\n  }\n  const iteration = parseInt(iterationText, 10)\n\n  return {\n    nonce,\n    salt,\n    iteration,\n  }\n}\n\nfunction parseServerFinalMessage(serverData) {\n  const attrPairs = parseAttributePairs(serverData)\n  const serverSignature = attrPairs.get('v')\n  if (!serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing')\n  } else if (!isBase64(serverSignature)) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64')\n  }\n  return {\n    serverSignature,\n  }\n}\n\nfunction xorBuffers(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    throw new TypeError('first argument must be a Buffer')\n  }\n  if (!Buffer.isBuffer(b)) {\n    throw new TypeError('second argument must be a Buffer')\n  }\n  if (a.length !== b.length) {\n    throw new Error('Buffer lengths must match')\n  }\n  if (a.length === 0) {\n    throw new Error('Buffers cannot be empty')\n  }\n  return Buffer.from(a.map((_, i) => a[i] ^ b[i]))\n}\n\nfunction sha256(text) {\n  return crypto.createHash('sha256').update(text).digest()\n}\n\nfunction hmacSha256(key, msg) {\n  return crypto.createHmac('sha256', key).update(msg).digest()\n}\n\nfunction Hi(password, saltBytes, iterations) {\n  var ui1 = hmacSha256(password, Buffer.concat([saltBytes, Buffer.from([0, 0, 0, 1])]))\n  var ui = ui1\n  for (var i = 0; i < iterations - 1; i++) {\n    ui1 = hmacSha256(password, ui1)\n    ui = xorBuffers(ui, ui1)\n  }\n\n  return ui\n}\n\nmodule.exports = {\n  startSession,\n  continueSession,\n  finalizeSession,\n}\n"]},"metadata":{},"sourceType":"script"}