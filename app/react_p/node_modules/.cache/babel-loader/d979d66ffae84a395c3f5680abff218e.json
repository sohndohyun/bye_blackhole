{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar sasl = require('./sasl');\n\nvar pgPass = require('pgpass');\n\nvar TypeOverrides = require('./type-overrides');\n\nvar ConnectionParameters = require('./connection-parameters');\n\nvar Query = require('./query');\n\nvar defaults = require('./defaults');\n\nvar Connection = require('./connection');\n\nclass Client extends EventEmitter {\n  constructor(config) {\n    super();\n    this.connectionParameters = new ConnectionParameters(config);\n    this.user = this.connectionParameters.user;\n    this.database = this.connectionParameters.database;\n    this.port = this.connectionParameters.port;\n    this.host = this.connectionParameters.host; // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: this.connectionParameters.password\n    });\n    this.replication = this.connectionParameters.replication;\n    var c = config || {};\n    this._Promise = c.Promise || global.Promise;\n    this._types = new TypeOverrides(c.types);\n    this._ending = false;\n    this._connecting = false;\n    this._connected = false;\n    this._connectionError = false;\n    this._queryable = true;\n    this.connection = c.connection || new Connection({\n      stream: c.stream,\n      ssl: this.connectionParameters.ssl,\n      keepAlive: c.keepAlive || false,\n      keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n      encoding: this.connectionParameters.client_encoding || 'utf8'\n    });\n    this.queryQueue = [];\n    this.binary = c.binary || defaults.binary;\n    this.processID = null;\n    this.secretKey = null;\n    this.ssl = this.connectionParameters.ssl || false; // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false\n      });\n    }\n\n    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;\n  }\n\n  _errorAllQueries(err) {\n    const enqueueError = query => {\n      process.nextTick(() => {\n        query.handleError(err, this.connection);\n      });\n    };\n\n    if (this.activeQuery) {\n      enqueueError(this.activeQuery);\n      this.activeQuery = null;\n    }\n\n    this.queryQueue.forEach(enqueueError);\n    this.queryQueue.length = 0;\n  }\n\n  _connect(callback) {\n    var self = this;\n    var con = this.connection;\n    this._connectionCallback = callback;\n\n    if (this._connecting || this._connected) {\n      const err = new Error('Client has already been connected. You cannot reuse a client.');\n      process.nextTick(() => {\n        callback(err);\n      });\n      return;\n    }\n\n    this._connecting = true;\n    this.connectionTimeoutHandle;\n\n    if (this._connectionTimeoutMillis > 0) {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        con._ending = true;\n        con.stream.destroy(new Error('timeout expired'));\n      }, this._connectionTimeoutMillis);\n    }\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port);\n    } else {\n      con.connect(this.port, this.host);\n    } // once connection is established send startup message\n\n\n    con.on('connect', function () {\n      if (self.ssl) {\n        con.requestSsl();\n      } else {\n        con.startup(self.getStartupConf());\n      }\n    });\n    con.on('sslconnect', function () {\n      con.startup(self.getStartupConf());\n    });\n\n    this._attachListeners(con);\n\n    con.once('end', () => {\n      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly');\n      clearTimeout(this.connectionTimeoutHandle);\n\n      this._errorAllQueries(error);\n\n      if (!this._ending) {\n        // if the connection is ended without us calling .end()\n        // on this client then we have an unexpected disconnection\n        // treat this as an error unless we've already emitted an error\n        // during connection.\n        if (this._connecting && !this._connectionError) {\n          if (this._connectionCallback) {\n            this._connectionCallback(error);\n          } else {\n            this._handleErrorEvent(error);\n          }\n        } else if (!this._connectionError) {\n          this._handleErrorEvent(error);\n        }\n      }\n\n      process.nextTick(() => {\n        this.emit('end');\n      });\n    });\n  }\n\n  connect(callback) {\n    if (callback) {\n      this._connect(callback);\n\n      return;\n    }\n\n    return new this._Promise((resolve, reject) => {\n      this._connect(error => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  _attachListeners(con) {\n    // password request handling\n    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this)); // password request handling\n\n    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this)); // password request handling (SASL)\n\n    con.on('authenticationSASL', this._handleAuthSASL.bind(this));\n    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this));\n    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this));\n    con.on('backendKeyData', this._handleBackendKeyData.bind(this));\n    con.on('error', this._handleErrorEvent.bind(this));\n    con.on('errorMessage', this._handleErrorMessage.bind(this));\n    con.on('readyForQuery', this._handleReadyForQuery.bind(this));\n    con.on('notice', this._handleNotice.bind(this));\n    con.on('rowDescription', this._handleRowDescription.bind(this));\n    con.on('dataRow', this._handleDataRow.bind(this));\n    con.on('portalSuspended', this._handlePortalSuspended.bind(this));\n    con.on('emptyQuery', this._handleEmptyQuery.bind(this));\n    con.on('commandComplete', this._handleCommandComplete.bind(this));\n    con.on('parseComplete', this._handleParseComplete.bind(this));\n    con.on('copyInResponse', this._handleCopyInResponse.bind(this));\n    con.on('copyData', this._handleCopyData.bind(this));\n    con.on('notification', this._handleNotification.bind(this));\n  } // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n  // it can be supplied by the user if required - this is a breaking change!\n\n\n  _checkPgPass(cb) {\n    const con = this.connection;\n\n    if (typeof this.password === 'function') {\n      this._Promise.resolve().then(() => this.password()).then(pass => {\n        if (pass !== undefined) {\n          if (typeof pass !== 'string') {\n            con.emit('error', new TypeError('Password must be a string'));\n            return;\n          }\n\n          this.connectionParameters.password = this.password = pass;\n        } else {\n          this.connectionParameters.password = this.password = null;\n        }\n\n        cb();\n      }).catch(err => {\n        con.emit('error', err);\n      });\n    } else if (this.password !== null) {\n      cb();\n    } else {\n      pgPass(this.connectionParameters, pass => {\n        if (undefined !== pass) {\n          this.connectionParameters.password = this.password = pass;\n        }\n\n        cb();\n      });\n    }\n  }\n\n  _handleAuthCleartextPassword(msg) {\n    this._checkPgPass(() => {\n      this.connection.password(this.password);\n    });\n  }\n\n  _handleAuthMD5Password(msg) {\n    this._checkPgPass(() => {\n      const hashedPassword = utils.postgresMd5PasswordHash(this.user, this.password, msg.salt);\n      this.connection.password(hashedPassword);\n    });\n  }\n\n  _handleAuthSASL(msg) {\n    this._checkPgPass(() => {\n      this.saslSession = sasl.startSession(msg.mechanisms);\n      this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);\n    });\n  }\n\n  _handleAuthSASLContinue(msg) {\n    sasl.continueSession(this.saslSession, this.password, msg.data);\n    this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);\n  }\n\n  _handleAuthSASLFinal(msg) {\n    sasl.finalizeSession(this.saslSession, msg.data);\n    this.saslSession = null;\n  }\n\n  _handleBackendKeyData(msg) {\n    this.processID = msg.processID;\n    this.secretKey = msg.secretKey;\n  }\n\n  _handleReadyForQuery(msg) {\n    if (this._connecting) {\n      this._connecting = false;\n      this._connected = true;\n      clearTimeout(this.connectionTimeoutHandle); // process possible callback argument to Client#connect\n\n      if (this._connectionCallback) {\n        this._connectionCallback(null, this); // remove callback for proper error handling\n        // after the connect event\n\n\n        this._connectionCallback = null;\n      }\n\n      this.emit('connect');\n    }\n\n    const {\n      activeQuery\n    } = this;\n    this.activeQuery = null;\n    this.readyForQuery = true;\n\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(this.connection);\n    }\n\n    this._pulseQueryQueue();\n  } // if we receieve an error event or error message\n  // during the connection process we handle it here\n\n\n  _handleErrorWhileConnecting(err) {\n    if (this._connectionError) {\n      // TODO(bmc): this is swallowing errors - we shouldn't do this\n      return;\n    }\n\n    this._connectionError = true;\n    clearTimeout(this.connectionTimeoutHandle);\n\n    if (this._connectionCallback) {\n      return this._connectionCallback(err);\n    }\n\n    this.emit('error', err);\n  } // if we're connected and we receive an error event from the connection\n  // this means the socket is dead - do a hard abort of all queries and emit\n  // the socket error on the client as well\n\n\n  _handleErrorEvent(err) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(err);\n    }\n\n    this._queryable = false;\n\n    this._errorAllQueries(err);\n\n    this.emit('error', err);\n  } // handle error messages from the postgres backend\n\n\n  _handleErrorMessage(msg) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(msg);\n    }\n\n    const activeQuery = this.activeQuery;\n\n    if (!activeQuery) {\n      this._handleErrorEvent(msg);\n\n      return;\n    }\n\n    this.activeQuery = null;\n    activeQuery.handleError(msg, this.connection);\n  }\n\n  _handleRowDescription(msg) {\n    // delegate rowDescription to active query\n    this.activeQuery.handleRowDescription(msg);\n  }\n\n  _handleDataRow(msg) {\n    // delegate dataRow to active query\n    this.activeQuery.handleDataRow(msg);\n  }\n\n  _handlePortalSuspended(msg) {\n    // delegate portalSuspended to active query\n    this.activeQuery.handlePortalSuspended(this.connection);\n  }\n\n  _handleEmptyQuery(msg) {\n    // delegate emptyQuery to active query\n    this.activeQuery.handleEmptyQuery(this.connection);\n  }\n\n  _handleCommandComplete(msg) {\n    // delegate commandComplete to active query\n    this.activeQuery.handleCommandComplete(msg, this.connection);\n  }\n\n  _handleParseComplete(msg) {\n    // if a prepared statement has a name and properly parses\n    // we track that its already been executed so we don't parse\n    // it again on the same client\n    if (this.activeQuery.name) {\n      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;\n    }\n  }\n\n  _handleCopyInResponse(msg) {\n    this.activeQuery.handleCopyInResponse(this.connection);\n  }\n\n  _handleCopyData(msg) {\n    this.activeQuery.handleCopyData(msg, this.connection);\n  }\n\n  _handleNotification(msg) {\n    this.emit('notification', msg);\n  }\n\n  _handleNotice(msg) {\n    this.emit('notice', msg);\n  }\n\n  getStartupConf() {\n    var params = this.connectionParameters;\n    var data = {\n      user: params.user,\n      database: params.database\n    };\n    var appName = params.application_name || params.fallback_application_name;\n\n    if (appName) {\n      data.application_name = appName;\n    }\n\n    if (params.replication) {\n      data.replication = '' + params.replication;\n    }\n\n    if (params.statement_timeout) {\n      data.statement_timeout = String(parseInt(params.statement_timeout, 10));\n    }\n\n    if (params.idle_in_transaction_session_timeout) {\n      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));\n    }\n\n    if (params.options) {\n      data.options = params.options;\n    }\n\n    return data;\n  }\n\n  cancel(client, query) {\n    if (client.activeQuery === query) {\n      var con = this.connection;\n\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port);\n      } else {\n        con.connect(this.port, this.host);\n      } // once connection is established send cancel message\n\n\n      con.on('connect', function () {\n        con.cancel(client.processID, client.secretKey);\n      });\n    } else if (client.queryQueue.indexOf(query) !== -1) {\n      client.queryQueue.splice(client.queryQueue.indexOf(query), 1);\n    }\n  }\n\n  setTypeParser(oid, format, parseFn) {\n    return this._types.setTypeParser(oid, format, parseFn);\n  }\n\n  getTypeParser(oid, format) {\n    return this._types.getTypeParser(oid, format);\n  } // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n\n  escapeIdentifier(str) {\n    return '\"' + str.replace(/\"/g, '\"\"') + '\"';\n  } // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n\n  escapeLiteral(str) {\n    var hasBackslash = false;\n    var escaped = \"'\";\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str[i];\n\n      if (c === \"'\") {\n        escaped += c + c;\n      } else if (c === '\\\\') {\n        escaped += c + c;\n        hasBackslash = true;\n      } else {\n        escaped += c;\n      }\n    }\n\n    escaped += \"'\";\n\n    if (hasBackslash === true) {\n      escaped = ' E' + escaped;\n    }\n\n    return escaped;\n  }\n\n  _pulseQueryQueue() {\n    if (this.readyForQuery === true) {\n      this.activeQuery = this.queryQueue.shift();\n\n      if (this.activeQuery) {\n        this.readyForQuery = false;\n        this.hasExecuted = true;\n        const queryError = this.activeQuery.submit(this.connection);\n\n        if (queryError) {\n          process.nextTick(() => {\n            this.activeQuery.handleError(queryError, this.connection);\n            this.readyForQuery = true;\n\n            this._pulseQueryQueue();\n          });\n        }\n      } else if (this.hasExecuted) {\n        this.activeQuery = null;\n        this.emit('drain');\n      }\n    }\n  }\n\n  query(config, values, callback) {\n    // can take in strings, config object or query object\n    var query;\n    var result;\n    var readTimeout;\n    var readTimeoutTimer;\n    var queryCallback;\n\n    if (config === null || config === undefined) {\n      throw new TypeError('Client was passed a null or undefined query');\n    } else if (typeof config.submit === 'function') {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;\n      result = query = config;\n\n      if (typeof values === 'function') {\n        query.callback = query.callback || values;\n      }\n    } else {\n      readTimeout = this.connectionParameters.query_timeout;\n      query = new Query(config, values, callback);\n\n      if (!query.callback) {\n        result = new this._Promise((resolve, reject) => {\n          query.callback = (err, res) => err ? reject(err) : resolve(res);\n        });\n      }\n    }\n\n    if (readTimeout) {\n      queryCallback = query.callback;\n      readTimeoutTimer = setTimeout(() => {\n        var error = new Error('Query read timeout');\n        process.nextTick(() => {\n          query.handleError(error, this.connection);\n        });\n        queryCallback(error); // we already returned an error,\n        // just do nothing if query completes\n\n        query.callback = () => {}; // Remove from queue\n\n\n        var index = this.queryQueue.indexOf(query);\n\n        if (index > -1) {\n          this.queryQueue.splice(index, 1);\n        }\n\n        this._pulseQueryQueue();\n      }, readTimeout);\n\n      query.callback = (err, res) => {\n        clearTimeout(readTimeoutTimer);\n        queryCallback(err, res);\n      };\n    }\n\n    if (this.binary && !query.binary) {\n      query.binary = true;\n    }\n\n    if (query._result && !query._result._types) {\n      query._result._types = this._types;\n    }\n\n    if (!this._queryable) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection);\n      });\n      return result;\n    }\n\n    if (this._ending) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client was closed and is not queryable'), this.connection);\n      });\n      return result;\n    }\n\n    this.queryQueue.push(query);\n\n    this._pulseQueryQueue();\n\n    return result;\n  }\n\n  end(cb) {\n    this._ending = true; // if we have never connected, then end is a noop, callback immediately\n\n    if (!this.connection._connecting) {\n      if (cb) {\n        cb();\n      } else {\n        return this._Promise.resolve();\n      }\n    }\n\n    if (this.activeQuery || !this._queryable) {\n      // if we have an active query we need to force a disconnect\n      // on the socket - otherwise a hung query could block end forever\n      this.connection.stream.destroy();\n    } else {\n      this.connection.end();\n    }\n\n    if (cb) {\n      this.connection.once('end', cb);\n    } else {\n      return new this._Promise(resolve => {\n        this.connection.once('end', resolve);\n      });\n    }\n  }\n\n} // expose a Query constructor\n\n\nClient.Query = Query;\nmodule.exports = Client;","map":{"version":3,"sources":["/Users/jinkim/bye_blackhole/app/node_modules/pg/lib/client.js"],"names":["EventEmitter","require","util","utils","sasl","pgPass","TypeOverrides","ConnectionParameters","Query","defaults","Connection","Client","constructor","config","connectionParameters","user","database","port","host","Object","defineProperty","configurable","enumerable","writable","value","password","replication","c","_Promise","Promise","global","_types","types","_ending","_connecting","_connected","_connectionError","_queryable","connection","stream","ssl","keepAlive","keepAliveInitialDelayMillis","encoding","client_encoding","queryQueue","binary","processID","secretKey","key","_connectionTimeoutMillis","connectionTimeoutMillis","_errorAllQueries","err","enqueueError","query","process","nextTick","handleError","activeQuery","forEach","length","_connect","callback","self","con","_connectionCallback","Error","connectionTimeoutHandle","setTimeout","destroy","indexOf","connect","on","requestSsl","startup","getStartupConf","_attachListeners","once","error","clearTimeout","_handleErrorEvent","emit","resolve","reject","_handleAuthCleartextPassword","bind","_handleAuthMD5Password","_handleAuthSASL","_handleAuthSASLContinue","_handleAuthSASLFinal","_handleBackendKeyData","_handleErrorMessage","_handleReadyForQuery","_handleNotice","_handleRowDescription","_handleDataRow","_handlePortalSuspended","_handleEmptyQuery","_handleCommandComplete","_handleParseComplete","_handleCopyInResponse","_handleCopyData","_handleNotification","_checkPgPass","cb","then","pass","undefined","TypeError","catch","msg","hashedPassword","postgresMd5PasswordHash","salt","saslSession","startSession","mechanisms","sendSASLInitialResponseMessage","mechanism","response","continueSession","data","sendSCRAMClientFinalMessage","finalizeSession","readyForQuery","handleReadyForQuery","_pulseQueryQueue","_handleErrorWhileConnecting","handleRowDescription","handleDataRow","handlePortalSuspended","handleEmptyQuery","handleCommandComplete","name","parsedStatements","text","handleCopyInResponse","handleCopyData","params","appName","application_name","fallback_application_name","statement_timeout","String","parseInt","idle_in_transaction_session_timeout","options","cancel","client","splice","setTypeParser","oid","format","parseFn","getTypeParser","escapeIdentifier","str","replace","escapeLiteral","hasBackslash","escaped","i","shift","hasExecuted","queryError","submit","values","result","readTimeout","readTimeoutTimer","queryCallback","query_timeout","res","index","_result","push","end","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar utils = require('./utils')\nvar sasl = require('./sasl')\nvar pgPass = require('pgpass')\nvar TypeOverrides = require('./type-overrides')\n\nvar ConnectionParameters = require('./connection-parameters')\nvar Query = require('./query')\nvar defaults = require('./defaults')\nvar Connection = require('./connection')\n\nclass Client extends EventEmitter {\n  constructor(config) {\n    super()\n\n    this.connectionParameters = new ConnectionParameters(config)\n    this.user = this.connectionParameters.user\n    this.database = this.connectionParameters.database\n    this.port = this.connectionParameters.port\n    this.host = this.connectionParameters.host\n\n    // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: this.connectionParameters.password,\n    })\n\n    this.replication = this.connectionParameters.replication\n\n    var c = config || {}\n\n    this._Promise = c.Promise || global.Promise\n    this._types = new TypeOverrides(c.types)\n    this._ending = false\n    this._connecting = false\n    this._connected = false\n    this._connectionError = false\n    this._queryable = true\n\n    this.connection =\n      c.connection ||\n      new Connection({\n        stream: c.stream,\n        ssl: this.connectionParameters.ssl,\n        keepAlive: c.keepAlive || false,\n        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n        encoding: this.connectionParameters.client_encoding || 'utf8',\n      })\n    this.queryQueue = []\n    this.binary = c.binary || defaults.binary\n    this.processID = null\n    this.secretKey = null\n    this.ssl = this.connectionParameters.ssl || false\n    // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0\n  }\n\n  _errorAllQueries(err) {\n    const enqueueError = (query) => {\n      process.nextTick(() => {\n        query.handleError(err, this.connection)\n      })\n    }\n\n    if (this.activeQuery) {\n      enqueueError(this.activeQuery)\n      this.activeQuery = null\n    }\n\n    this.queryQueue.forEach(enqueueError)\n    this.queryQueue.length = 0\n  }\n\n  _connect(callback) {\n    var self = this\n    var con = this.connection\n    this._connectionCallback = callback\n\n    if (this._connecting || this._connected) {\n      const err = new Error('Client has already been connected. You cannot reuse a client.')\n      process.nextTick(() => {\n        callback(err)\n      })\n      return\n    }\n    this._connecting = true\n\n    this.connectionTimeoutHandle\n    if (this._connectionTimeoutMillis > 0) {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        con._ending = true\n        con.stream.destroy(new Error('timeout expired'))\n      }, this._connectionTimeoutMillis)\n    }\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port)\n    } else {\n      con.connect(this.port, this.host)\n    }\n\n    // once connection is established send startup message\n    con.on('connect', function () {\n      if (self.ssl) {\n        con.requestSsl()\n      } else {\n        con.startup(self.getStartupConf())\n      }\n    })\n\n    con.on('sslconnect', function () {\n      con.startup(self.getStartupConf())\n    })\n\n    this._attachListeners(con)\n\n    con.once('end', () => {\n      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly')\n\n      clearTimeout(this.connectionTimeoutHandle)\n      this._errorAllQueries(error)\n\n      if (!this._ending) {\n        // if the connection is ended without us calling .end()\n        // on this client then we have an unexpected disconnection\n        // treat this as an error unless we've already emitted an error\n        // during connection.\n        if (this._connecting && !this._connectionError) {\n          if (this._connectionCallback) {\n            this._connectionCallback(error)\n          } else {\n            this._handleErrorEvent(error)\n          }\n        } else if (!this._connectionError) {\n          this._handleErrorEvent(error)\n        }\n      }\n\n      process.nextTick(() => {\n        this.emit('end')\n      })\n    })\n  }\n\n  connect(callback) {\n    if (callback) {\n      this._connect(callback)\n      return\n    }\n\n    return new this._Promise((resolve, reject) => {\n      this._connect((error) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  _attachListeners(con) {\n    // password request handling\n    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this))\n    // password request handling\n    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this))\n    // password request handling (SASL)\n    con.on('authenticationSASL', this._handleAuthSASL.bind(this))\n    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this))\n    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this))\n    con.on('backendKeyData', this._handleBackendKeyData.bind(this))\n    con.on('error', this._handleErrorEvent.bind(this))\n    con.on('errorMessage', this._handleErrorMessage.bind(this))\n    con.on('readyForQuery', this._handleReadyForQuery.bind(this))\n    con.on('notice', this._handleNotice.bind(this))\n    con.on('rowDescription', this._handleRowDescription.bind(this))\n    con.on('dataRow', this._handleDataRow.bind(this))\n    con.on('portalSuspended', this._handlePortalSuspended.bind(this))\n    con.on('emptyQuery', this._handleEmptyQuery.bind(this))\n    con.on('commandComplete', this._handleCommandComplete.bind(this))\n    con.on('parseComplete', this._handleParseComplete.bind(this))\n    con.on('copyInResponse', this._handleCopyInResponse.bind(this))\n    con.on('copyData', this._handleCopyData.bind(this))\n    con.on('notification', this._handleNotification.bind(this))\n  }\n\n  // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n  // it can be supplied by the user if required - this is a breaking change!\n  _checkPgPass(cb) {\n    const con = this.connection\n    if (typeof this.password === 'function') {\n      this._Promise\n        .resolve()\n        .then(() => this.password())\n        .then((pass) => {\n          if (pass !== undefined) {\n            if (typeof pass !== 'string') {\n              con.emit('error', new TypeError('Password must be a string'))\n              return\n            }\n            this.connectionParameters.password = this.password = pass\n          } else {\n            this.connectionParameters.password = this.password = null\n          }\n          cb()\n        })\n        .catch((err) => {\n          con.emit('error', err)\n        })\n    } else if (this.password !== null) {\n      cb()\n    } else {\n      pgPass(this.connectionParameters, (pass) => {\n        if (undefined !== pass) {\n          this.connectionParameters.password = this.password = pass\n        }\n        cb()\n      })\n    }\n  }\n\n  _handleAuthCleartextPassword(msg) {\n    this._checkPgPass(() => {\n      this.connection.password(this.password)\n    })\n  }\n\n  _handleAuthMD5Password(msg) {\n    this._checkPgPass(() => {\n      const hashedPassword = utils.postgresMd5PasswordHash(this.user, this.password, msg.salt)\n      this.connection.password(hashedPassword)\n    })\n  }\n\n  _handleAuthSASL(msg) {\n    this._checkPgPass(() => {\n      this.saslSession = sasl.startSession(msg.mechanisms)\n      this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response)\n    })\n  }\n\n  _handleAuthSASLContinue(msg) {\n    sasl.continueSession(this.saslSession, this.password, msg.data)\n    this.connection.sendSCRAMClientFinalMessage(this.saslSession.response)\n  }\n\n  _handleAuthSASLFinal(msg) {\n    sasl.finalizeSession(this.saslSession, msg.data)\n    this.saslSession = null\n  }\n\n  _handleBackendKeyData(msg) {\n    this.processID = msg.processID\n    this.secretKey = msg.secretKey\n  }\n\n  _handleReadyForQuery(msg) {\n    if (this._connecting) {\n      this._connecting = false\n      this._connected = true\n      clearTimeout(this.connectionTimeoutHandle)\n\n      // process possible callback argument to Client#connect\n      if (this._connectionCallback) {\n        this._connectionCallback(null, this)\n        // remove callback for proper error handling\n        // after the connect event\n        this._connectionCallback = null\n      }\n      this.emit('connect')\n    }\n    const { activeQuery } = this\n    this.activeQuery = null\n    this.readyForQuery = true\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(this.connection)\n    }\n    this._pulseQueryQueue()\n  }\n\n  // if we receieve an error event or error message\n  // during the connection process we handle it here\n  _handleErrorWhileConnecting(err) {\n    if (this._connectionError) {\n      // TODO(bmc): this is swallowing errors - we shouldn't do this\n      return\n    }\n    this._connectionError = true\n    clearTimeout(this.connectionTimeoutHandle)\n    if (this._connectionCallback) {\n      return this._connectionCallback(err)\n    }\n    this.emit('error', err)\n  }\n\n  // if we're connected and we receive an error event from the connection\n  // this means the socket is dead - do a hard abort of all queries and emit\n  // the socket error on the client as well\n  _handleErrorEvent(err) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(err)\n    }\n    this._queryable = false\n    this._errorAllQueries(err)\n    this.emit('error', err)\n  }\n\n  // handle error messages from the postgres backend\n  _handleErrorMessage(msg) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(msg)\n    }\n    const activeQuery = this.activeQuery\n\n    if (!activeQuery) {\n      this._handleErrorEvent(msg)\n      return\n    }\n\n    this.activeQuery = null\n    activeQuery.handleError(msg, this.connection)\n  }\n\n  _handleRowDescription(msg) {\n    // delegate rowDescription to active query\n    this.activeQuery.handleRowDescription(msg)\n  }\n\n  _handleDataRow(msg) {\n    // delegate dataRow to active query\n    this.activeQuery.handleDataRow(msg)\n  }\n\n  _handlePortalSuspended(msg) {\n    // delegate portalSuspended to active query\n    this.activeQuery.handlePortalSuspended(this.connection)\n  }\n\n  _handleEmptyQuery(msg) {\n    // delegate emptyQuery to active query\n    this.activeQuery.handleEmptyQuery(this.connection)\n  }\n\n  _handleCommandComplete(msg) {\n    // delegate commandComplete to active query\n    this.activeQuery.handleCommandComplete(msg, this.connection)\n  }\n\n  _handleParseComplete(msg) {\n    // if a prepared statement has a name and properly parses\n    // we track that its already been executed so we don't parse\n    // it again on the same client\n    if (this.activeQuery.name) {\n      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text\n    }\n  }\n\n  _handleCopyInResponse(msg) {\n    this.activeQuery.handleCopyInResponse(this.connection)\n  }\n\n  _handleCopyData(msg) {\n    this.activeQuery.handleCopyData(msg, this.connection)\n  }\n\n  _handleNotification(msg) {\n    this.emit('notification', msg)\n  }\n\n  _handleNotice(msg) {\n    this.emit('notice', msg)\n  }\n\n  getStartupConf() {\n    var params = this.connectionParameters\n\n    var data = {\n      user: params.user,\n      database: params.database,\n    }\n\n    var appName = params.application_name || params.fallback_application_name\n    if (appName) {\n      data.application_name = appName\n    }\n    if (params.replication) {\n      data.replication = '' + params.replication\n    }\n    if (params.statement_timeout) {\n      data.statement_timeout = String(parseInt(params.statement_timeout, 10))\n    }\n    if (params.idle_in_transaction_session_timeout) {\n      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10))\n    }\n    if (params.options) {\n      data.options = params.options\n    }\n\n    return data\n  }\n\n  cancel(client, query) {\n    if (client.activeQuery === query) {\n      var con = this.connection\n\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port)\n      } else {\n        con.connect(this.port, this.host)\n      }\n\n      // once connection is established send cancel message\n      con.on('connect', function () {\n        con.cancel(client.processID, client.secretKey)\n      })\n    } else if (client.queryQueue.indexOf(query) !== -1) {\n      client.queryQueue.splice(client.queryQueue.indexOf(query), 1)\n    }\n  }\n\n  setTypeParser(oid, format, parseFn) {\n    return this._types.setTypeParser(oid, format, parseFn)\n  }\n\n  getTypeParser(oid, format) {\n    return this._types.getTypeParser(oid, format)\n  }\n\n  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n  escapeIdentifier(str) {\n    return '\"' + str.replace(/\"/g, '\"\"') + '\"'\n  }\n\n  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n  escapeLiteral(str) {\n    var hasBackslash = false\n    var escaped = \"'\"\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str[i]\n      if (c === \"'\") {\n        escaped += c + c\n      } else if (c === '\\\\') {\n        escaped += c + c\n        hasBackslash = true\n      } else {\n        escaped += c\n      }\n    }\n\n    escaped += \"'\"\n\n    if (hasBackslash === true) {\n      escaped = ' E' + escaped\n    }\n\n    return escaped\n  }\n\n  _pulseQueryQueue() {\n    if (this.readyForQuery === true) {\n      this.activeQuery = this.queryQueue.shift()\n      if (this.activeQuery) {\n        this.readyForQuery = false\n        this.hasExecuted = true\n\n        const queryError = this.activeQuery.submit(this.connection)\n        if (queryError) {\n          process.nextTick(() => {\n            this.activeQuery.handleError(queryError, this.connection)\n            this.readyForQuery = true\n            this._pulseQueryQueue()\n          })\n        }\n      } else if (this.hasExecuted) {\n        this.activeQuery = null\n        this.emit('drain')\n      }\n    }\n  }\n\n  query(config, values, callback) {\n    // can take in strings, config object or query object\n    var query\n    var result\n    var readTimeout\n    var readTimeoutTimer\n    var queryCallback\n\n    if (config === null || config === undefined) {\n      throw new TypeError('Client was passed a null or undefined query')\n    } else if (typeof config.submit === 'function') {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n      result = query = config\n      if (typeof values === 'function') {\n        query.callback = query.callback || values\n      }\n    } else {\n      readTimeout = this.connectionParameters.query_timeout\n      query = new Query(config, values, callback)\n      if (!query.callback) {\n        result = new this._Promise((resolve, reject) => {\n          query.callback = (err, res) => (err ? reject(err) : resolve(res))\n        })\n      }\n    }\n\n    if (readTimeout) {\n      queryCallback = query.callback\n\n      readTimeoutTimer = setTimeout(() => {\n        var error = new Error('Query read timeout')\n\n        process.nextTick(() => {\n          query.handleError(error, this.connection)\n        })\n\n        queryCallback(error)\n\n        // we already returned an error,\n        // just do nothing if query completes\n        query.callback = () => {}\n\n        // Remove from queue\n        var index = this.queryQueue.indexOf(query)\n        if (index > -1) {\n          this.queryQueue.splice(index, 1)\n        }\n\n        this._pulseQueryQueue()\n      }, readTimeout)\n\n      query.callback = (err, res) => {\n        clearTimeout(readTimeoutTimer)\n        queryCallback(err, res)\n      }\n    }\n\n    if (this.binary && !query.binary) {\n      query.binary = true\n    }\n\n    if (query._result && !query._result._types) {\n      query._result._types = this._types\n    }\n\n    if (!this._queryable) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    if (this._ending) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client was closed and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    this.queryQueue.push(query)\n    this._pulseQueryQueue()\n    return result\n  }\n\n  end(cb) {\n    this._ending = true\n\n    // if we have never connected, then end is a noop, callback immediately\n    if (!this.connection._connecting) {\n      if (cb) {\n        cb()\n      } else {\n        return this._Promise.resolve()\n      }\n    }\n\n    if (this.activeQuery || !this._queryable) {\n      // if we have an active query we need to force a disconnect\n      // on the socket - otherwise a hung query could block end forever\n      this.connection.stream.destroy()\n    } else {\n      this.connection.end()\n    }\n\n    if (cb) {\n      this.connection.once('end', cb)\n    } else {\n      return new this._Promise((resolve) => {\n        this.connection.once('end', resolve)\n      })\n    }\n  }\n}\n\n// expose a Query constructor\nClient.Query = Query\n\nmodule.exports = Client\n"]},"metadata":{},"sourceType":"script"}