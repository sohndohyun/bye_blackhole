{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nconst messages_1 = require(\"./messages\");\n\nconst buffer_reader_1 = require(\"./buffer-reader\");\n\nconst assert_1 = __importDefault(require(\"assert\")); // every message is prefixed with a single bye\n\n\nconst CODE_LENGTH = 1; // every message has an int32 length which includes itself but does\n// NOT include the code in the length\n\nconst LEN_LENGTH = 4;\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nconst emptyBuffer = Buffer.allocUnsafe(0);\n\nclass Parser {\n  constructor(opts) {\n    this.buffer = emptyBuffer;\n    this.bufferLength = 0;\n    this.bufferOffset = 0;\n    this.reader = new buffer_reader_1.BufferReader();\n\n    if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\n      throw new Error('Binary mode not supported yet');\n    }\n\n    this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\n  }\n\n  parse(buffer, callback) {\n    this.mergeBuffer(buffer);\n    const bufferFullLength = this.bufferOffset + this.bufferLength;\n    let offset = this.bufferOffset;\n\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = this.buffer[offset]; // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n      const fullMessageLength = CODE_LENGTH + length;\n\n      if (fullMessageLength + offset <= bufferFullLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n        callback(message);\n        offset += fullMessageLength;\n      } else {\n        break;\n      }\n    }\n\n    if (offset === bufferFullLength) {\n      // No more use for the buffer\n      this.buffer = emptyBuffer;\n      this.bufferLength = 0;\n      this.bufferOffset = 0;\n    } else {\n      // Adjust the cursors of remainingBuffer\n      this.bufferLength = bufferFullLength - offset;\n      this.bufferOffset = offset;\n    }\n  }\n\n  mergeBuffer(buffer) {\n    if (this.bufferLength > 0) {\n      const newLength = this.bufferLength + buffer.byteLength;\n      const newFullLength = newLength + this.bufferOffset;\n\n      if (newFullLength > this.buffer.byteLength) {\n        // We can't concat the new buffer with the remaining one\n        let newBuffer;\n\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n          newBuffer = this.buffer;\n        } else {\n          // Allocate a new larger buffer\n          let newBufferLength = this.buffer.byteLength * 2;\n\n          while (newLength >= newBufferLength) {\n            newBufferLength *= 2;\n          }\n\n          newBuffer = Buffer.allocUnsafe(newBufferLength);\n        } // Move the remaining buffer to the new one\n\n\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n        this.buffer = newBuffer;\n        this.bufferOffset = 0;\n      } // Concat the new buffer with the remaining one\n\n\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n      this.bufferLength = newLength;\n    } else {\n      this.buffer = buffer;\n      this.bufferOffset = 0;\n      this.bufferLength = buffer.byteLength;\n    }\n  }\n\n  handlePacket(offset, code, length, bytes) {\n    switch (code) {\n      case 50\n      /* BindComplete */\n      :\n        return messages_1.bindComplete;\n\n      case 49\n      /* ParseComplete */\n      :\n        return messages_1.parseComplete;\n\n      case 51\n      /* CloseComplete */\n      :\n        return messages_1.closeComplete;\n\n      case 110\n      /* NoData */\n      :\n        return messages_1.noData;\n\n      case 115\n      /* PortalSuspended */\n      :\n        return messages_1.portalSuspended;\n\n      case 99\n      /* CopyDone */\n      :\n        return messages_1.copyDone;\n\n      case 87\n      /* ReplicationStart */\n      :\n        return messages_1.replicationStart;\n\n      case 73\n      /* EmptyQuery */\n      :\n        return messages_1.emptyQuery;\n\n      case 68\n      /* DataRow */\n      :\n        return this.parseDataRowMessage(offset, length, bytes);\n\n      case 67\n      /* CommandComplete */\n      :\n        return this.parseCommandCompleteMessage(offset, length, bytes);\n\n      case 90\n      /* ReadyForQuery */\n      :\n        return this.parseReadyForQueryMessage(offset, length, bytes);\n\n      case 65\n      /* NotificationResponse */\n      :\n        return this.parseNotificationMessage(offset, length, bytes);\n\n      case 82\n      /* AuthenticationResponse */\n      :\n        return this.parseAuthenticationResponse(offset, length, bytes);\n\n      case 83\n      /* ParameterStatus */\n      :\n        return this.parseParameterStatusMessage(offset, length, bytes);\n\n      case 75\n      /* BackendKeyData */\n      :\n        return this.parseBackendKeyData(offset, length, bytes);\n\n      case 69\n      /* ErrorMessage */\n      :\n        return this.parseErrorMessage(offset, length, bytes, 'error');\n\n      case 78\n      /* NoticeMessage */\n      :\n        return this.parseErrorMessage(offset, length, bytes, 'notice');\n\n      case 84\n      /* RowDescriptionMessage */\n      :\n        return this.parseRowDescriptionMessage(offset, length, bytes);\n\n      case 116\n      /* ParameterDescriptionMessage */\n      :\n        return this.parseParameterDescriptionMessage(offset, length, bytes);\n\n      case 71\n      /* CopyIn */\n      :\n        return this.parseCopyInMessage(offset, length, bytes);\n\n      case 72\n      /* CopyOut */\n      :\n        return this.parseCopyOutMessage(offset, length, bytes);\n\n      case 100\n      /* CopyData */\n      :\n        return this.parseCopyData(offset, length, bytes);\n\n      default:\n        assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\n    }\n  }\n\n  parseReadyForQueryMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const status = this.reader.string(1);\n    return new messages_1.ReadyForQueryMessage(length, status);\n  }\n\n  parseCommandCompleteMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const text = this.reader.cstring();\n    return new messages_1.CommandCompleteMessage(length, text);\n  }\n\n  parseCopyData(offset, length, bytes) {\n    const chunk = bytes.slice(offset, offset + (length - 4));\n    return new messages_1.CopyDataMessage(length, chunk);\n  }\n\n  parseCopyInMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n  }\n\n  parseCopyOutMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n  }\n\n  parseCopyMessage(offset, length, bytes, messageName) {\n    this.reader.setBuffer(offset, bytes);\n    const isBinary = this.reader.byte() !== 0;\n    const columnCount = this.reader.int16();\n    const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16();\n    }\n\n    return message;\n  }\n\n  parseNotificationMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processId = this.reader.int32();\n    const channel = this.reader.cstring();\n    const payload = this.reader.cstring();\n    return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n  }\n\n  parseRowDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const message = new messages_1.RowDescriptionMessage(length, fieldCount);\n\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField();\n    }\n\n    return message;\n  }\n\n  parseField() {\n    const name = this.reader.cstring();\n    const tableID = this.reader.int32();\n    const columnID = this.reader.int16();\n    const dataTypeID = this.reader.int32();\n    const dataTypeSize = this.reader.int16();\n    const dataTypeModifier = this.reader.int32();\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n    return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n  }\n\n  parseParameterDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const parameterCount = this.reader.int16();\n    const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\n\n    for (let i = 0; i < parameterCount; i++) {\n      message.dataTypeIDs[i] = this.reader.int32();\n    }\n\n    return message;\n  }\n\n  parseDataRowMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const fields = new Array(fieldCount);\n\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32(); // a -1 for length means the value of the field is null\n\n      fields[i] = len === -1 ? null : this.reader.string(len);\n    }\n\n    return new messages_1.DataRowMessage(length, fields);\n  }\n\n  parseParameterStatusMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const name = this.reader.cstring();\n    const value = this.reader.cstring();\n    return new messages_1.ParameterStatusMessage(length, name, value);\n  }\n\n  parseBackendKeyData(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processID = this.reader.int32();\n    const secretKey = this.reader.int32();\n    return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n  }\n\n  parseAuthenticationResponse(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const code = this.reader.int32(); // TODO(bmc): maybe better types here\n\n    const message = {\n      name: 'authenticationOk',\n      length\n    };\n\n    switch (code) {\n      case 0:\n        // AuthenticationOk\n        break;\n\n      case 3:\n        // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = 'authenticationCleartextPassword';\n        }\n\n        break;\n\n      case 5:\n        // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = 'authenticationMD5Password';\n          const salt = this.reader.bytes(4);\n          return new messages_1.AuthenticationMD5Password(length, salt);\n        }\n\n        break;\n\n      case 10:\n        // AuthenticationSASL\n        message.name = 'authenticationSASL';\n        message.mechanisms = [];\n        let mechanism;\n\n        do {\n          mechanism = this.reader.cstring();\n\n          if (mechanism) {\n            message.mechanisms.push(mechanism);\n          }\n        } while (mechanism);\n\n        break;\n\n      case 11:\n        // AuthenticationSASLContinue\n        message.name = 'authenticationSASLContinue';\n        message.data = this.reader.string(length - 8);\n        break;\n\n      case 12:\n        // AuthenticationSASLFinal\n        message.name = 'authenticationSASLFinal';\n        message.data = this.reader.string(length - 8);\n        break;\n\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code);\n    }\n\n    return message;\n  }\n\n  parseErrorMessage(offset, length, bytes, name) {\n    this.reader.setBuffer(offset, bytes);\n    const fields = {};\n    let fieldType = this.reader.string(1);\n\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring();\n      fieldType = this.reader.string(1);\n    }\n\n    const messageValue = fields.M;\n    const message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n    message.severity = fields.S;\n    message.code = fields.C;\n    message.detail = fields.D;\n    message.hint = fields.H;\n    message.position = fields.P;\n    message.internalPosition = fields.p;\n    message.internalQuery = fields.q;\n    message.where = fields.W;\n    message.schema = fields.s;\n    message.table = fields.t;\n    message.column = fields.c;\n    message.dataType = fields.d;\n    message.constraint = fields.n;\n    message.file = fields.F;\n    message.line = fields.L;\n    message.routine = fields.R;\n    return message;\n  }\n\n}\n\nexports.Parser = Parser;","map":{"version":3,"sources":["../src/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst messages_1 = require(\"./messages\");\nconst buffer_reader_1 = require(\"./buffer-reader\");\nconst assert_1 = __importDefault(require(\"assert\"));\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1;\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4;\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nconst emptyBuffer = Buffer.allocUnsafe(0);\nclass Parser {\n    constructor(opts) {\n        this.buffer = emptyBuffer;\n        this.bufferLength = 0;\n        this.bufferOffset = 0;\n        this.reader = new buffer_reader_1.BufferReader();\n        if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\n            throw new Error('Binary mode not supported yet');\n        }\n        this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\n    }\n    parse(buffer, callback) {\n        this.mergeBuffer(buffer);\n        const bufferFullLength = this.bufferOffset + this.bufferLength;\n        let offset = this.bufferOffset;\n        while (offset + HEADER_LENGTH <= bufferFullLength) {\n            // code is 1 byte long - it identifies the message type\n            const code = this.buffer[offset];\n            // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n            const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n            const fullMessageLength = CODE_LENGTH + length;\n            if (fullMessageLength + offset <= bufferFullLength) {\n                const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n                callback(message);\n                offset += fullMessageLength;\n            }\n            else {\n                break;\n            }\n        }\n        if (offset === bufferFullLength) {\n            // No more use for the buffer\n            this.buffer = emptyBuffer;\n            this.bufferLength = 0;\n            this.bufferOffset = 0;\n        }\n        else {\n            // Adjust the cursors of remainingBuffer\n            this.bufferLength = bufferFullLength - offset;\n            this.bufferOffset = offset;\n        }\n    }\n    mergeBuffer(buffer) {\n        if (this.bufferLength > 0) {\n            const newLength = this.bufferLength + buffer.byteLength;\n            const newFullLength = newLength + this.bufferOffset;\n            if (newFullLength > this.buffer.byteLength) {\n                // We can't concat the new buffer with the remaining one\n                let newBuffer;\n                if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n                    // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n                    newBuffer = this.buffer;\n                }\n                else {\n                    // Allocate a new larger buffer\n                    let newBufferLength = this.buffer.byteLength * 2;\n                    while (newLength >= newBufferLength) {\n                        newBufferLength *= 2;\n                    }\n                    newBuffer = Buffer.allocUnsafe(newBufferLength);\n                }\n                // Move the remaining buffer to the new one\n                this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n                this.buffer = newBuffer;\n                this.bufferOffset = 0;\n            }\n            // Concat the new buffer with the remaining one\n            buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n            this.bufferLength = newLength;\n        }\n        else {\n            this.buffer = buffer;\n            this.bufferOffset = 0;\n            this.bufferLength = buffer.byteLength;\n        }\n    }\n    handlePacket(offset, code, length, bytes) {\n        switch (code) {\n            case 50 /* BindComplete */:\n                return messages_1.bindComplete;\n            case 49 /* ParseComplete */:\n                return messages_1.parseComplete;\n            case 51 /* CloseComplete */:\n                return messages_1.closeComplete;\n            case 110 /* NoData */:\n                return messages_1.noData;\n            case 115 /* PortalSuspended */:\n                return messages_1.portalSuspended;\n            case 99 /* CopyDone */:\n                return messages_1.copyDone;\n            case 87 /* ReplicationStart */:\n                return messages_1.replicationStart;\n            case 73 /* EmptyQuery */:\n                return messages_1.emptyQuery;\n            case 68 /* DataRow */:\n                return this.parseDataRowMessage(offset, length, bytes);\n            case 67 /* CommandComplete */:\n                return this.parseCommandCompleteMessage(offset, length, bytes);\n            case 90 /* ReadyForQuery */:\n                return this.parseReadyForQueryMessage(offset, length, bytes);\n            case 65 /* NotificationResponse */:\n                return this.parseNotificationMessage(offset, length, bytes);\n            case 82 /* AuthenticationResponse */:\n                return this.parseAuthenticationResponse(offset, length, bytes);\n            case 83 /* ParameterStatus */:\n                return this.parseParameterStatusMessage(offset, length, bytes);\n            case 75 /* BackendKeyData */:\n                return this.parseBackendKeyData(offset, length, bytes);\n            case 69 /* ErrorMessage */:\n                return this.parseErrorMessage(offset, length, bytes, 'error');\n            case 78 /* NoticeMessage */:\n                return this.parseErrorMessage(offset, length, bytes, 'notice');\n            case 84 /* RowDescriptionMessage */:\n                return this.parseRowDescriptionMessage(offset, length, bytes);\n            case 116 /* ParameterDescriptionMessage */:\n                return this.parseParameterDescriptionMessage(offset, length, bytes);\n            case 71 /* CopyIn */:\n                return this.parseCopyInMessage(offset, length, bytes);\n            case 72 /* CopyOut */:\n                return this.parseCopyOutMessage(offset, length, bytes);\n            case 100 /* CopyData */:\n                return this.parseCopyData(offset, length, bytes);\n            default:\n                assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\n        }\n    }\n    parseReadyForQueryMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const status = this.reader.string(1);\n        return new messages_1.ReadyForQueryMessage(length, status);\n    }\n    parseCommandCompleteMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const text = this.reader.cstring();\n        return new messages_1.CommandCompleteMessage(length, text);\n    }\n    parseCopyData(offset, length, bytes) {\n        const chunk = bytes.slice(offset, offset + (length - 4));\n        return new messages_1.CopyDataMessage(length, chunk);\n    }\n    parseCopyInMessage(offset, length, bytes) {\n        return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n    }\n    parseCopyOutMessage(offset, length, bytes) {\n        return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n    }\n    parseCopyMessage(offset, length, bytes, messageName) {\n        this.reader.setBuffer(offset, bytes);\n        const isBinary = this.reader.byte() !== 0;\n        const columnCount = this.reader.int16();\n        const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n        for (let i = 0; i < columnCount; i++) {\n            message.columnTypes[i] = this.reader.int16();\n        }\n        return message;\n    }\n    parseNotificationMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const processId = this.reader.int32();\n        const channel = this.reader.cstring();\n        const payload = this.reader.cstring();\n        return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n    }\n    parseRowDescriptionMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const fieldCount = this.reader.int16();\n        const message = new messages_1.RowDescriptionMessage(length, fieldCount);\n        for (let i = 0; i < fieldCount; i++) {\n            message.fields[i] = this.parseField();\n        }\n        return message;\n    }\n    parseField() {\n        const name = this.reader.cstring();\n        const tableID = this.reader.int32();\n        const columnID = this.reader.int16();\n        const dataTypeID = this.reader.int32();\n        const dataTypeSize = this.reader.int16();\n        const dataTypeModifier = this.reader.int32();\n        const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n        return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n    }\n    parseParameterDescriptionMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const parameterCount = this.reader.int16();\n        const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\n        for (let i = 0; i < parameterCount; i++) {\n            message.dataTypeIDs[i] = this.reader.int32();\n        }\n        return message;\n    }\n    parseDataRowMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const fieldCount = this.reader.int16();\n        const fields = new Array(fieldCount);\n        for (let i = 0; i < fieldCount; i++) {\n            const len = this.reader.int32();\n            // a -1 for length means the value of the field is null\n            fields[i] = len === -1 ? null : this.reader.string(len);\n        }\n        return new messages_1.DataRowMessage(length, fields);\n    }\n    parseParameterStatusMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const name = this.reader.cstring();\n        const value = this.reader.cstring();\n        return new messages_1.ParameterStatusMessage(length, name, value);\n    }\n    parseBackendKeyData(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const processID = this.reader.int32();\n        const secretKey = this.reader.int32();\n        return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n    }\n    parseAuthenticationResponse(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const code = this.reader.int32();\n        // TODO(bmc): maybe better types here\n        const message = {\n            name: 'authenticationOk',\n            length,\n        };\n        switch (code) {\n            case 0: // AuthenticationOk\n                break;\n            case 3: // AuthenticationCleartextPassword\n                if (message.length === 8) {\n                    message.name = 'authenticationCleartextPassword';\n                }\n                break;\n            case 5: // AuthenticationMD5Password\n                if (message.length === 12) {\n                    message.name = 'authenticationMD5Password';\n                    const salt = this.reader.bytes(4);\n                    return new messages_1.AuthenticationMD5Password(length, salt);\n                }\n                break;\n            case 10: // AuthenticationSASL\n                message.name = 'authenticationSASL';\n                message.mechanisms = [];\n                let mechanism;\n                do {\n                    mechanism = this.reader.cstring();\n                    if (mechanism) {\n                        message.mechanisms.push(mechanism);\n                    }\n                } while (mechanism);\n                break;\n            case 11: // AuthenticationSASLContinue\n                message.name = 'authenticationSASLContinue';\n                message.data = this.reader.string(length - 8);\n                break;\n            case 12: // AuthenticationSASLFinal\n                message.name = 'authenticationSASLFinal';\n                message.data = this.reader.string(length - 8);\n                break;\n            default:\n                throw new Error('Unknown authenticationOk message type ' + code);\n        }\n        return message;\n    }\n    parseErrorMessage(offset, length, bytes, name) {\n        this.reader.setBuffer(offset, bytes);\n        const fields = {};\n        let fieldType = this.reader.string(1);\n        while (fieldType !== '\\0') {\n            fields[fieldType] = this.reader.cstring();\n            fieldType = this.reader.string(1);\n        }\n        const messageValue = fields.M;\n        const message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n        message.severity = fields.S;\n        message.code = fields.C;\n        message.detail = fields.D;\n        message.hint = fields.H;\n        message.position = fields.P;\n        message.internalPosition = fields.p;\n        message.internalQuery = fields.q;\n        message.where = fields.W;\n        message.schema = fields.s;\n        message.table = fields.t;\n        message.column = fields.c;\n        message.dataType = fields.d;\n        message.constraint = fields.n;\n        message.file = fields.F;\n        message.line = fields.L;\n        message.routine = fields.R;\n        return message;\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"script"}